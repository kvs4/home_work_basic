// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const ChangeEmailUser = `-- name: ChangeEmailUser :one
UPDATE shop."Users" SET email = $1
WHERE name = $2
returning id, name, email
`

type ChangeEmailUserParams struct {
	Email *string `db:"email" json:"email"`
	Name  *string `db:"name" json:"name"`
}

type ChangeEmailUserRow struct {
	ID    pgtype.UUID `db:"id" json:"id"`
	Name  *string     `db:"name" json:"name"`
	Email *string     `db:"email" json:"email"`
}

func (q *Queries) ChangeEmailUser(ctx context.Context, arg ChangeEmailUserParams) (*ChangeEmailUserRow, error) {
	row := q.db.QueryRow(ctx, ChangeEmailUser, arg.Email, arg.Name)
	var i ChangeEmailUserRow
	err := row.Scan(&i.ID, &i.Name, &i.Email)
	return &i, err
}

const ChangePriceProduct = `-- name: ChangePriceProduct :one
UPDATE shop."Products" SET price = $1
WHERE name = $2
returning id, name, price
`

type ChangePriceProductParams struct {
	Price pgtype.Numeric `db:"price" json:"price"`
	Name  *string        `db:"name" json:"name"`
}

func (q *Queries) ChangePriceProduct(ctx context.Context, arg ChangePriceProductParams) (*ShopProduct, error) {
	row := q.db.QueryRow(ctx, ChangePriceProduct, arg.Price, arg.Name)
	var i ShopProduct
	err := row.Scan(&i.ID, &i.Name, &i.Price)
	return &i, err
}

const CreateOrder = `-- name: CreateOrder :one
INSERT INTO Shop."Orders" (user_id, order_date, total_amount)
VALUES ($1, $2, $3)
returning id, user_id, order_date, total_amount
`

type CreateOrderParams struct {
	UserID      pgtype.UUID        `db:"user_id" json:"user_id"`
	OrderDate   pgtype.Timestamptz `db:"order_date" json:"order_date"`
	TotalAmount pgtype.Numeric     `db:"total_amount" json:"total_amount"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (*ShopOrder, error) {
	row := q.db.QueryRow(ctx, CreateOrder, arg.UserID, arg.OrderDate, arg.TotalAmount)
	var i ShopOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderDate,
		&i.TotalAmount,
	)
	return &i, err
}

const CreateOrderProducts = `-- name: CreateOrderProducts :one
INSERT INTO shop."OrderProducts" (order_id, product_id)
VALUES ($1, $2)
returning id, order_id, product_id
`

type CreateOrderProductsParams struct {
	OrderID   pgtype.UUID `db:"order_id" json:"order_id"`
	ProductID pgtype.UUID `db:"product_id" json:"product_id"`
}

func (q *Queries) CreateOrderProducts(ctx context.Context, arg CreateOrderProductsParams) (*ShopOrderProduct, error) {
	row := q.db.QueryRow(ctx, CreateOrderProducts, arg.OrderID, arg.ProductID)
	var i ShopOrderProduct
	err := row.Scan(&i.ID, &i.OrderID, &i.ProductID)
	return &i, err
}

const CreateProduct = `-- name: CreateProduct :one
INSERT INTO shop."Products" (name, price)
VALUES ($1, $2)
returning id, name
`

type CreateProductParams struct {
	Name  *string        `db:"name" json:"name"`
	Price pgtype.Numeric `db:"price" json:"price"`
}

type CreateProductRow struct {
	ID   pgtype.UUID `db:"id" json:"id"`
	Name *string     `db:"name" json:"name"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (*CreateProductRow, error) {
	row := q.db.QueryRow(ctx, CreateProduct, arg.Name, arg.Price)
	var i CreateProductRow
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const CreateUser = `-- name: CreateUser :one
INSERT INTO Shop."Users" (name, email, password)
VALUES ($1, $2, $3)
returning id, name
`

type CreateUserParams struct {
	Name     *string `db:"name" json:"name"`
	Email    *string `db:"email" json:"email"`
	Password *string `db:"password" json:"password"`
}

type CreateUserRow struct {
	ID   pgtype.UUID `db:"id" json:"id"`
	Name *string     `db:"name" json:"name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (*CreateUserRow, error) {
	row := q.db.QueryRow(ctx, CreateUser, arg.Name, arg.Email, arg.Password)
	var i CreateUserRow
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const DeleteOrder = `-- name: DeleteOrder :one
delete from shop."Orders" where id = $1
returning id, user_id, order_date, total_amount
`

func (q *Queries) DeleteOrder(ctx context.Context, id pgtype.UUID) (*ShopOrder, error) {
	row := q.db.QueryRow(ctx, DeleteOrder, id)
	var i ShopOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderDate,
		&i.TotalAmount,
	)
	return &i, err
}

const DeleteOrderProducts = `-- name: DeleteOrderProducts :one
delete from shop."OrderProducts" where order_id = $1
returning id, order_id, product_id
`

func (q *Queries) DeleteOrderProducts(ctx context.Context, orderID pgtype.UUID) (*ShopOrderProduct, error) {
	row := q.db.QueryRow(ctx, DeleteOrderProducts, orderID)
	var i ShopOrderProduct
	err := row.Scan(&i.ID, &i.OrderID, &i.ProductID)
	return &i, err
}

const DeleteProduct = `-- name: DeleteProduct :one
DELETE FROM shop."Products" WHERE name = $1
returning id, name
`

type DeleteProductRow struct {
	ID   pgtype.UUID `db:"id" json:"id"`
	Name *string     `db:"name" json:"name"`
}

func (q *Queries) DeleteProduct(ctx context.Context, name *string) (*DeleteProductRow, error) {
	row := q.db.QueryRow(ctx, DeleteProduct, name)
	var i DeleteProductRow
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const DeleteUser = `-- name: DeleteUser :one
DELETE FROM shop."Users" WHERE name = $1
returning id, name
`

type DeleteUserRow struct {
	ID   pgtype.UUID `db:"id" json:"id"`
	Name *string     `db:"name" json:"name"`
}

func (q *Queries) DeleteUser(ctx context.Context, name *string) (*DeleteUserRow, error) {
	row := q.db.QueryRow(ctx, DeleteUser, name)
	var i DeleteUserRow
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const GetProduct = `-- name: GetProduct :one
SELECT id, name, price
	FROM shop."Products"
WHERE name = $1
`

func (q *Queries) GetProduct(ctx context.Context, name *string) (*ShopProduct, error) {
	row := q.db.QueryRow(ctx, GetProduct, name)
	var i ShopProduct
	err := row.Scan(&i.ID, &i.Name, &i.Price)
	return &i, err
}

const GetProducts = `-- name: GetProducts :many
SELECT id, name, price
	FROM shop."Products"
`

func (q *Queries) GetProducts(ctx context.Context) ([]*ShopProduct, error) {
	rows, err := q.db.Query(ctx, GetProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ShopProduct{}
	for rows.Next() {
		var i ShopProduct
		if err := rows.Scan(&i.ID, &i.Name, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUser = `-- name: GetUser :one
SELECT id, name, email, password
	FROM shop."Users"
WHERE name = $1
`

func (q *Queries) GetUser(ctx context.Context, name *string) (*ShopUser, error) {
	row := q.db.QueryRow(ctx, GetUser, name)
	var i ShopUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return &i, err
}

const GetUserStatistics = `-- name: GetUserStatistics :one
WITH AvgPriceInOrder AS (
SELECT 
	Users.name as user_name, 
	Users.email as user_email,  
	Orders.total_amount, 
	AVG(Prod.price) as average_price
	FROM shop."Orders" Orders
	LEFT JOIN shop."Users" Users ON Orders.user_id = Users.id
	LEFT JOIN shop."OrderProducts" OrderProd ON Orders.id = OrderProd.order_id
		LEFT JOIN shop."Products" Prod ON OrderProd.product_id = Prod.id
	WHERE Users."name" = $1
	GROUP BY 
		user_name, 
		user_email, 
		Orders.total_amount 
		
	)
	
SELECT
	user_name,
	user_email, 
	SUM (total_amount) as sum_amount,
	AVG(average_price) as average_price
	
	FROM AvgPriceInOrder
GROUP BY 
		user_name, 
		user_email
`

type GetUserStatisticsRow struct {
	UserName     *string `db:"user_name" json:"user_name"`
	UserEmail    *string `db:"user_email" json:"user_email"`
	//SumAmount    int64   `db:"sum_amount" json:"sum_amount"`
	SumAmount	pgtype.Numeric `db:"sum_amount" json:"sum_amount"`
	//AveragePrice float64 `db:"average_price" json:"average_price"`
	AveragePrice pgtype.Numeric `db:"average_price" json:"average_price"`
}

func (q *Queries) GetUserStatistics(ctx context.Context, name *string) (*GetUserStatisticsRow, error) {
	row := q.db.QueryRow(ctx, GetUserStatistics, name)
	var i GetUserStatisticsRow
	err := row.Scan(
		&i.UserName,
		&i.UserEmail,
		&i.SumAmount,
		&i.AveragePrice,
	)
	return &i, err
}

const GetUsers = `-- name: GetUsers :many
SELECT id, name, email, password
	FROM shop."Users"
`

func (q *Queries) GetUsers(ctx context.Context) ([]*ShopUser, error) {
	rows, err := q.db.Query(ctx, GetUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ShopUser{}
	for rows.Next() {
		var i ShopUser
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersOrders = `-- name: GetUsersOrders :many
SELECT 
	Users.name as user_name, 
	Users.email as user_email, 
	Orders.id as Order_id, 
	Orders.order_date, 
	Orders.total_amount, 
	Prod.name as product, 
	Prod.price
	FROM shop."Orders" Orders
	LEFT JOIN shop."Users" Users ON Orders.user_id = Users.id
	LEFT JOIN shop."OrderProducts" OrderProd ON Orders.id = OrderProd.order_id
		LEFT JOIN shop."Products" Prod ON OrderProd.product_id = Prod.id
`

type GetUsersOrdersRow struct {
	UserName    *string            `db:"user_name" json:"user_name"`
	UserEmail   *string            `db:"user_email" json:"user_email"`
	OrderID     pgtype.UUID        `db:"order_id" json:"order_id"`
	OrderDate   pgtype.Timestamptz `db:"order_date" json:"order_date"`
	TotalAmount pgtype.Numeric     `db:"total_amount" json:"total_amount"`
	Product     *string            `db:"product" json:"product"`
	Price       pgtype.Numeric     `db:"price" json:"price"`
}

func (q *Queries) GetUsersOrders(ctx context.Context) ([]*GetUsersOrdersRow, error) {
	rows, err := q.db.Query(ctx, GetUsersOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUsersOrdersRow{}
	for rows.Next() {
		var i GetUsersOrdersRow
		if err := rows.Scan(
			&i.UserName,
			&i.UserEmail,
			&i.OrderID,
			&i.OrderDate,
			&i.TotalAmount,
			&i.Product,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
